---
title: "CS 128 - Intro to Computer Science II"
subject: "CS"
number: 128
credits: 3
description: "Continuation of CS 124. More advanced concepts in computing and techniques and approaches for solving computational problems."
instructor: Michael Nowak
prerequisites: ["CS 124"]
tags: ["core"]
---

This is the second CS core class for all CS/CS+X majors, comprising of online asynchronous lectures and mandatory discussion sections, much like CS124. Machine Problems (MPs) are released on biweekly-ish basis. These are larger-scale programming assignments that target the programming concepts covered in lecture. The output of the machine problem is autograded in PrairieLearn for correctness. There are also weekly-ish quizzes admisistered through the CBTF, which also cover lecture content. Please see the [syllabus](https://cs128.org/2026a/syllabus-1644) for the most up-to-date information on the course's structure.

## Topics Covered
- Writing and compiling C++ code
- Use of algorithms and data structures to achieve a desired end result
- Introduction to computing and computer system concepts such as memory access (pointers), memory management, and computational complexity
- Command line debugging tools such as GDB and Valgrind

## Resources
Online office hours as hosted as specified in the syllabus. [learncpp.online](https://learncpp.online/lessons) is a public-facing version of the material taught in this course. For C++ documentation, [Cpp Reference](https://cppreference.com/) is often the standard, but can be very difficult to read. [cplusplus.com](https://cplusplus.com/reference/) is a little easier to look at. Note that assignments for CS128 likely use an older standard of C++; keep this in mind when reading C++ documentation.

## Developer's Commentary
This class is likely one of the first times you will begin to solve real-world-style problems with programming. Designing a solution is not inherently intuitive; rather, it is a learned skill. Before approaching an MP, please read the specification and provided code in full, and sketch out a sensible solution before starting implementation. This gives you the opportunity to justify the correctness of your solution before engaging in the (potentially long) task of writing out all the code. Beyond just the scope of this class, the skill of taking a problem, architecting a solution, justifying its behaviour, and then implementing it correctly is a critical skill for both higher-level classes and for computer science roles as a whole. Building a strong foundation in this skill now will prove immensely valuable for your future educational and professional career. 

As a logical continuation of the previous section, please donâ€™t take the easy way out and use LLMs for machine problems. Learning to write code is much like learning mathematics. In primary school, we are taught to perform arithmetic by hand, which helps build our intuition for numbers, operations, and error-checking. Only after these fundamentals become second nature are we permitted to use calculators- not as a crutch, but as a tool to extend our reach. Programming follows a similar trajectory. Writing code by hand forces us to reason precisely, consider edge cases, and develop a mental model between the code we write and what the machine actually does. Skipping this skill often leads to a superficial literacy without a deeper understanding for what our code does. LLMs, like calculators, are immensely powerful tools, but they are only effective once the underlying skills are cemented. 

Command Line Interfaces (CLIs) may not be intuitive at first, but being able to comfortably use command line tools is a necessary skill for CS and CS-adjacent majors. Make sure to take the time to learn how to use the command line to do basic functions like viewing and changing directories, creating new directories/files, deleting directories/files, and renaming directories/files. 

You can technically get away with not learning how to use GDB and Valgrind in this class. Please don't do this. GDB and Valgrind are extremely useful debugging tools; although the MPs in this class may be simple enough to get away with only print statement debugging, learning and getting comfortable with GDB and Valgrind will save you from many headaches in future classes. 

## Proficiency Exam
This course does offer a proficiency exam. For exam logistics, please refer to the [official CS proficiency exam website](https://proficiency.cs.illinois.edu/) and the [CS128 Proficiency Site](https://cs128.org/2022a/proficiency-exam-information-277).